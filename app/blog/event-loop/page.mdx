import MdxLayout from "@/components/mdx-layout";

export const metadata = {
    title: 'Event loop | Blog',
    description: 'Event loop в javascript',
};

<MdxLayout>
    # Event Loop

    Event Loop (цикл событий) в JavaScript — это механизм, который управляет выполнением асинхронного кода в
    однопоточном окружении. JavaScript является языком с однопоточностью, что означает, что в любой момент времени может
    выполняться только одна операция. Однако благодаря Event Loop и системе очередей, JavaScript способен обрабатывать
    асинхронные операции, такие как сетевые запросы, таймеры и обработка событий, параллельно с основным потоком
    выполнения.

    ## Основные компоненты Event Loop

    1. **Call Stack (стек вызовов)**: Это структура данных, где хранятся функции, которые ожидают выполнения. Когда
    функция вызывается, она помещается в стек вызовов. После завершения выполнения она удаляется из стека.
    2. **Web APIs (веб-интерфейсы)**: Это набор интерфейсов, предоставляемых средой исполнения JavaScript (например,
    браузером или Node.js), которые позволяют выполнять асинхронные операции. К ним относятся, например, setTimeout,
    XMLHttpRequest и другие.
    3. **Task Queue (очередь задач)**: Это очередь, куда попадают завершённые асинхронные задачи, ожидающие выполнения.
    После того как стек вызовов пуст, Event Loop берёт первую задачу из очереди и добавляет её в стек вызовов для
    выполнения.
    4. **Microtask Queue (микрозадачи)**: Это отдельная очередь для микрозадач, таких как обещания (Promise) и
    MutationObserver. Микрозадачи имеют более высокий приоритет, чем обычные задачи, и выполняются сразу после
    завершения текущего выполнения в стеке вызовов, но до следующей задачи из основной очереди.

    ## Как работает Event Loop

    1. **Запуск основного потока**: Когда начинается выполнение программы, основной поток помещает все синхронные
    операции в стек вызовов.
    2. **Асинхронные операции**: Когда встречается асинхронная операция (например, setTimeout или fetch), она передается
    соответствующим Web API. Эти API выполняют операцию в параллельном потоке, освобождая основной поток для продолжения
    выполнения других операций.
    3. **Завершение асинхронных операций**: Когда асинхронная операция завершается, она добавляется в Task Queue или
    Microtask Queue в зависимости от типа задачи.
    4. **Проверка стека вызовов**: Event Loop постоянно проверяет стек вызовов. Если стек пуст, он берет следующую
    задачу из очереди (сначала из Microtask Queue, затем из Task Queue) и помещает её в стек вызовов для выполнения.
    5. **Выполнение асинхронных задач**: Таким образом, асинхронные задачи выполняются только тогда, когда стек вызовов
    пуст, что предотвращает блокировки основного потока.

    Рассмотрим следующий пример:

    ```javascript
    console.log("Start");

    setTimeout(() => {
        console.log("SetTimeout");
    }, 0);

    Promise.resolve().then(() => {
        console.log("Promise");
    });

    console.log("End");
    ```

    Последовательность вывода будет следующая:

    1. **"Start"** - выводится сразу, так как это синхронная операция.
    2. **"End"** - выводится следующим, потому что это тоже синхронная операция.
    3. **"Promise"** - выводится третьим, так как это микрозадача, которая выполняется сразу после завершения синхронных операций.
    4. **"SetTimeout"** - выводится последним, так как это обычная задача из Task Queue, которая выполняется после всех микрозадач.

    ## Заключение

    Event Loop — это ключевой механизм, который позволяет JavaScript эффективно управлять асинхронными операциями в однопоточной среде. Понимая, как он работает, разработчики могут создавать более производительные и устойчивые к ошибкам веб-приложения.
</MdxLayout>